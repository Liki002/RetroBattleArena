<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pixel Boss Battleground</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Press Start 2P', cursive;
      background-color: #000;
      color: #fff;
      overflow: hidden;
      image-rendering: pixelated;
    }
    
    /* CRT screen effect */
    #crtEffect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(18, 16, 16, 0.1) 50%, rgba(0, 0, 0, 0.25) 50%), 
                  linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      background-size: 100% 4px, 3px 100%;
      pointer-events: none;
      z-index: 100;
    }
    
    /* Main container with scanlines */
    #gameContainer {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      font-size: 0.85em;
      background-color: #111;
      position: relative;
      border: 4px solid #444;
      box-shadow: 0 0 20px #0ff;
    }
    
    /* Scanlines effect */
    #gameContainer::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        to bottom,
        transparent 0%,
        rgba(0, 255, 255, 0.05) 50%,
        transparent 100%
      );
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 1;
    }
    
    .title {
      font-size: 2em;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #0ff, 2px 2px 4px #000;
      color: #ff0;
      position: relative;
    }
    
    /* BOSS AREA */
    #bossContainer {
      position: relative;
      width: 100%;
      height: 360px;
      margin-bottom: 20px;
      overflow: hidden;
      border: 3px solid #444;
      background: #000;
    }
    
    /* Health container at the top */
    #bossHealthContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 5px 10px;
      box-sizing: border-box;
      z-index: 2;
    }
    
    #bossHealthBar {
      width: 100%;
      background: #444;
      border-radius: 10px;
      overflow: hidden;
      height: 25px;
      margin-bottom: 5px;
      border: 2px solid #222;
      box-shadow: 0 0 5px #f00;
    }
    
    #bossHealthFill {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #ff4d4d, #990000);
      transition: width 0.5s;
    }
    
    #bossHealthText {
      font-size: 1.1em;
      font-weight: bold;
      text-shadow: 1px 1px 3px #000;
      color: #fff;
    }
    
    /* Phase indicator */
    #bossPhaseIndicator {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
      border: 2px solid #f00;
      font-size: 0.8em;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 3;
    }
    
    .phaseVisible {
      opacity: 1 !important;
    }
    
    /* Boss Avatar Wrapper */
    #bossAvatarWrapper {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      transition: left 0.5s, top 0.5s;
      z-index: 1;
    }
    
    #bossCanvas {
      width: 240px;
      height: 240px;
      max-width: 100%;
      image-rendering: pixelated;
      filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7));
    }
    
    /* Blood flash overlay */
    #bloodFlash {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 0, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out;
      z-index: 3;
    }
    
    .bloodVisible {
      opacity: 1 !important;
    }
    
    /* Boss flicker + shake animation */
    @keyframes twitchFlicker {
      0% { opacity: 1; transform: translate(0, 0); }
      20% { opacity: 0.5; transform: translate(-5px, 5px); }
      40% { opacity: 1; transform: translate(5px, -5px); }
      60% { opacity: 0.5; transform: translate(-5px, 5px); }
      80% { opacity: 1; transform: translate(5px, -5px); }
      100% { opacity: 1; transform: translate(0, 0); }
    }
    
    .hurt {
      animation: twitchFlicker 0.3s;
    }
    
    /* Boss entrance animation */
    @keyframes bossEntrance {
      0% { transform: translateX(-50%) scale(0.1); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.2); opacity: 1; }
      100% { transform: translateX(-50%) scale(1); }
    }
    
    .bossEntrance {
      animation: bossEntrance 0.8s ease-out;
    }
    
    /* Boss death animation */
    @keyframes bossDeath {
      0% { transform: translateX(-50%) scale(1); opacity: 1; }
      50% { transform: translateX(-50%) scale(1.5); opacity: 0.8; }
      100% { transform: translateX(-50%) scale(0.1); opacity: 0; }
    }
    
    .bossDeath {
      animation: bossDeath 0.8s ease-out;
    }
    
    /* Boss attack animation */
    @keyframes bossAttack {
      0% { transform: translateX(-50%) scale(1); }
      20% { transform: translateX(-50%) scale(1.1); }
      40% { transform: translateX(-50%) scale(0.9); }
      60% { transform: translateX(-50%) scale(1.05); }
      80% { transform: translateX(-50%) scale(0.95); }
      100% { transform: translateX(-50%) scale(1); }
    }
    
    .bossAttacking {
      animation: bossAttack 0.5s;
    }
    
    /* Projectile styles */
    .bossProjectile {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      z-index: 2;
      pointer-events: none;
    }
    
    /* Chat Log styling */
    #chatLog {
      height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.7);
      border: 2px solid #555;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 15px;
      text-align: left;
      font-size: 0.8em;
      box-shadow: inset 0 0 10px #000;
    }
    
    #chatLog div {
      margin: 5px 0;
      opacity: 0;
      animation: fadeIn 0.5s forwards;
      line-height: 1.4;
    }
    
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    
    /* Scoreboard styling */
    #scoreboard {
      background: rgba(0,0,0,0.7);
      border: 2px solid #555;
      border-radius: 10px;
      padding: 10px;
      margin-top: 15px;
      text-align: left;
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.8em;
      box-shadow: inset 0 0 10px #000;
    }
    
    #scoreboard h2 {
      margin-top: 0;
      font-size: 1em;
      text-align: center;
      color: #ff0;
    }
    
    /* Each player entry spacing */
    #scoreboardContent div {
      margin-bottom: 10px;
      line-height: 1.3;
    }
    
    .levelUp {
      color: #ff0;
      font-size: 0.8em;
      margin-left: 5px;
      animation: levelUpFlash 2s ease-out;
    }
    
    @keyframes levelUpFlash {
      0% { opacity: 1; text-shadow: 0 0 5px #ff0; }
      100% { opacity: 0; text-shadow: 0 0 10px #ff0; }
    }
    
    /* Special effects */
    .criticalHit {
      color: #ff0;
      text-shadow: 0 0 5px #f80;
      font-weight: bold;
    }
    
    .miss {
      color: #888;
      font-style: italic;
    }
    
    /* Player class indicators */
    .warrior { color: #f55; }
    .mage { color: #5af; }
    .rogue { color: #fa5; }
    .cleric { color: #5f5; }
    .ranger { color: #8f5; }
    
    /* Action buttons */
    .action-buttons {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .action-btn {
      background: #333;
      border: 2px solid #555;
      color: #fff;
      padding: 8px 15px;
      font-family: 'Press Start 2P', cursive;
      font-size: 0.7em;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      min-width: 120px;
    }
    
    .action-btn:hover {
      background: #555;
      border-color: #0ff;
      color: #0ff;
      text-shadow: 0 0 5px #0ff;
    }
    
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Cooldown indicators */
    .cooldown-indicator {
      height: 5px;
      background: #444;
      margin-top: 5px;
    }
    
    .cooldown-fill {
      height: 100%;
      background: #0ff;
      width: 0%;
      transition: width 0.1s linear;
    }
    
    /* Inventory and equipment */
    #inventoryPanel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      border: 4px solid #555;
      border-radius: 10px;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 0 20px #0ff;
    }
    
    #inventoryPanel h2 {
      margin-top: 0;
      color: #ff0;
      text-align: center;
    }
    
    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    
    .inventory-item {
      background: rgba(50,50,50,0.5);
      border: 2px solid #555;
      border-radius: 5px;
      padding: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .inventory-item:hover {
      border-color: #0ff;
      background: rgba(50,50,50,0.8);
    }
    
    .inventory-item img {
      width: 100%;
      height: auto;
      image-rendering: pixelated;
    }
    
    .inventory-item-name {
      font-size: 0.7em;
      margin-top: 5px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .item-rarity-common { color: #fff; }
    .item-rarity-uncommon { color: #5f5; }
    .item-rarity-rare { color: #55f; }
    .item-rarity-epic { color: #a5f; }
    .item-rarity-legendary { color: #fa5; }
    
    .close-inventory {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #f55;
      border: none;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      font-weight: bold;
    }
    
    /* Status effects */
    .status-effect {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 3px;
      vertical-align: middle;
    }
    
    .status-poison { background: #5f5; }
    .status-burn { background: #f55; }
    .status-freeze { background: #5af; }
    .status-stun { background: #ff5; }
    .status-buff { background: #5f5; }
    .status-debuff { background: #f55; }
    
    /* Sleek/invisible scrollbar styling */
    #scoreboard::-webkit-scrollbar,
    #chatLog::-webkit-scrollbar,
    #inventoryPanel::-webkit-scrollbar {
      width: 6px;
    }
    
    #scoreboard::-webkit-scrollbar-thumb,
    #chatLog::-webkit-scrollbar-thumb,
    #inventoryPanel::-webkit-scrollbar-thumb {
      background-color: rgba(255,255,255,0.3);
      border-radius: 3px;
    }
    
    /* Mobile responsiveness */
    @media (max-width: 600px) {
      .title {
        font-size: 1.5em;
      }
      
      .action-buttons {
        flex-direction: column;
      }
      
      .action-btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <!-- CRT screen effect overlay -->
  <div id="crtEffect"></div>

  <!-- Hidden input for testing username -->
  <input type="hidden" id="testUsernameInput" value="Player">
  
  <div id="gameContainer">
    <h1 class="title">PIXEL BOSS BATTLEGROUND</h1>
    
    <!-- Boss Container -->
    <div id="bossContainer">
      <!-- Blood flash overlay -->
      <div id="bloodFlash"></div>
      
      <!-- Phase indicator -->
      <div id="bossPhaseIndicator">PHASE 1</div>
      
      <!-- Health container at the top -->
      <div id="bossHealthContainer">
        <div id="bossHealthBar">
          <div id="bossHealthFill"></div>
        </div>
        <div id="bossHealthText">1000 / 1000</div>
      </div>
      
      <!-- Boss Canvas below the health container -->
      <div id="bossAvatarWrapper">
        <canvas id="bossCanvas" width="64" height="64"></canvas>
      </div>
    </div>
    
    <!-- Action Buttons -->
    <div class="action-buttons">
      <div>
        <button id="attackBtn" class="action-btn">ATTACK</button>
        <div id="attackCooldown" class="cooldown-indicator">
          <div id="attackCooldownFill" class="cooldown-fill"></div>
        </div>
      </div>
      <div>
        <button id="specialAttackBtn" class="action-btn">SPECIAL</button>
        <div id="specialAttackCooldown" class="cooldown-indicator">
          <div id="specialAttackCooldownFill" class="cooldown-fill"></div>
        </div>
      </div>
      <div>
        <button id="ability1Btn" class="action-btn">ABILITY 1</button>
        <div id="ability1Cooldown" class="cooldown-indicator">
          <div id="ability1CooldownFill" class="cooldown-fill"></div>
        </div>
      </div>
      <div>
        <button id="ability2Btn" class="action-btn">ABILITY 2</button>
        <div id="ability2Cooldown" class="cooldown-indicator">
          <div id="ability2CooldownFill" class="cooldown-fill"></div>
        </div>
      </div>
      <button id="inventoryBtn" class="action-btn">INVENTORY</button>
    </div>
    
    <!-- Chat log -->
    <div id="chatLog"></div>
    
    <!-- Scoreboard -->
    <div id="scoreboard">
      <h2>SCOREBOARD</h2>
      <div id="scoreboardContent">No players yet.</div>
    </div>
  </div>
  
  <!-- Inventory Panel -->
  <div id="inventoryPanel">
    <button class="close-inventory">X</button>
    <h2>INVENTORY</h2>
    <div id="equipmentSlots">
      <h3>EQUIPPED ITEMS</h3>
      <div id="equippedItems"></div>
    </div>
    <div id="inventoryItems">
      <h3>INVENTORY</h3>
      <div class="inventory-grid" id="inventoryGrid"></div>
    </div>
  </div>
  
  <script>
    // ======================
    // GAME STATE VARIABLES
    // ======================
    
    // Player classes with abilities
    const playerClasses = {
      warrior: {
        name: "Warrior",
        description: "Strong melee fighter with high damage and defense",
        stats: { str: 10, dex: 5, int: 3, vit: 8 },
        abilities: [
          {
            name: "Power Strike",
            description: "Deals heavy damage with a chance to stun",
            cooldown: 5,
            execute: (player) => {
              const damage = Math.floor(30 + (player.stats.str * 1.5) + Math.floor(Math.random() * 21));
              const isStun = Math.random() < 0.3;
              return { damage, effects: isStun ? [{ type: "stun", duration: 2 }] : [] };
            }
          },
          {
            name: "Taunt",
            description: "Draws boss attention and reduces damage taken by allies",
            cooldown: 10,
            execute: (player) => {
              return { damage: 0, effects: [{ type: "taunt", duration: 5 }] };
            }
          }
        ]
      },
      mage: {
        name: "Mage",
        description: "Powerful spellcaster with elemental attacks",
        stats: { str: 3, dex: 5, int: 10, vit: 4 },
        abilities: [
          {
            name: "Fireball",
            description: "Launches a fiery projectile that burns the target",
            cooldown: 4,
            execute: (player) => {
              const damage = Math.floor(20 + (player.stats.int * 1.8) + Math.floor(Math.random() * 16));
              const isBurn = Math.random() < 0.4;
              return { damage, effects: isBurn ? [{ type: "burn", duration: 3 }] : [] };
            }
          },
          {
            name: "Arcane Shield",
            description: "Creates a protective barrier for allies",
            cooldown: 12,
            execute: (player) => {
              return { damage: 0, effects: [{ type: "shield", duration: 6 }] };
            }
          }
        ]
      },
      rogue: {
        name: "Rogue",
        description: "Quick and deadly with high critical chance",
        stats: { str: 6, dex: 10, int: 4, vit: 5 },
        abilities: [
          {
            name: "Backstab",
            description: "Deals massive damage from behind",
            cooldown: 6,
            execute: (player) => {
              const damage = Math.floor(40 + (player.stats.dex * 2) + Math.floor(Math.random() * 31));
              return { damage, effects: [] };
            }
          },
          {
            name: "Poison Dart",
            description: "Poisons the target over time",
            cooldown: 8,
            execute: (player) => {
              const damage = Math.floor(15 + (player.stats.dex * 0.8) + Math.floor(Math.random() * 11));
              return { damage, effects: [{ type: "poison", duration: 5 }] };
            }
          }
        ]
      },
      cleric: {
        name: "Cleric",
        description: "Healer and support with holy magic",
        stats: { str: 4, dex: 4, int: 8, vit: 6 },
        abilities: [
          {
            name: "Heal",
            description: "Restores health to allies",
            cooldown: 5,
            execute: (player) => {
              const heal = Math.floor(30 + (player.stats.int * 1.5) + Math.floor(Math.random() * 21));
              return { heal, effects: [] };
            }
          },
          {
            name: "Smite",
            description: "Holy attack that deals extra damage to undead",
            cooldown: 7,
            execute: (player) => {
              const isUndead = currentBoss.tags.includes("undead");
              const damage = Math.floor(25 + (player.stats.int * 1.2) + Math.floor(Math.random() * 16)) * (isUndead ? 1.5 : 1);
              return { damage, effects: [] };
            }
          }
        ]
      },
      ranger: {
        name: "Ranger",
        description: "Ranged attacker with animal companions",
        stats: { str: 5, dex: 8, int: 5, vit: 6 },
        abilities: [
          {
            name: "Multi-Shot",
            description: "Fires multiple arrows at once",
            cooldown: 5,
            execute: (player) => {
              const hits = 2 + Math.floor(player.stats.dex / 5);
              let totalDamage = 0;
              for (let i = 0; i < hits; i++) {
                totalDamage += Math.floor(10 + (player.stats.dex * 0.8) + Math.floor(Math.random() * 11));
              }
              return { damage: totalDamage, effects: [] };
            }
          },
          {
            name: "Call Companion",
            description: "Summons an animal to assist in battle",
            cooldown: 15,
            execute: (player) => {
              return { damage: 0, effects: [{ type: "companion", duration: 10 }] };
            }
          }
        ]
      }
    };
    
    // Boss types with generation parameters
    const bossTypes = [
      {
        name: "Inferno Dragon",
        healthMultiplier: 1.0,
        description: "A fire-breathing dragon from the depths of the volcano!",
        specialWeakness: "ice",
        palette: ['#330000', '#660000', '#990000', '#cc0000', '#ff0000', '#ff6600', '#ff9900'],
        complexity: 5,
        symmetry: 0.7,
        tags: ["dragon", "fire"],
        attackPatterns: [
          {
            name: "Fire Breath",
            damage: 50,
            effect: { type: "burn", duration: 3 },
            cooldown: 8,
            execute: () => {
              // Visual effect for fire breath
              fireBreathAttack();
              return { damage: 50, effects: [{ type: "burn", duration: 3 }] };
            }
          },
          {
            name: "Wing Buffet",
            damage: 30,
            effect: { type: "knockback", duration: 1 },
            cooldown: 5,
            execute: () => {
              bossAvatarWrapper.classList.add('bossAttacking');
              setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
              return { damage: 30, effects: [{ type: "knockback", duration: 1 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.7, name: "Phase 2: Enraged", effect: "Attack speed increased by 30%" },
          { threshold: 0.3, name: "Phase 3: Berserk", effect: "Damage increased by 50%" }
        ]
      },
      {
        name: "Titanium Golem",
        healthMultiplier: 1.2,
        description: "A massive metal golem awakened from ancient ruins!",
        specialWeakness: "lightning",
        palette: ['#111111', '#333333', '#555555', '#777777', '#999999', '#bbbbbb', '#dddddd'],
        complexity: 4,
        symmetry: 0.9,
        tags: ["construct", "metal"],
        attackPatterns: [
          {
            name: "Crushing Fist",
            damage: 60,
            effect: { type: "stun", duration: 1 },
            cooldown: 6,
            execute: () => {
              bossAvatarWrapper.classList.add('bossAttacking');
              setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
              return { damage: 60, effects: [{ type: "stun", duration: 1 }] };
            }
          },
          {
            name: "Shockwave",
            damage: 40,
            effect: { type: "knockback", duration: 1 },
            cooldown: 10,
            execute: () => {
              shockwaveAttack();
              return { damage: 40, effects: [{ type: "knockback", duration: 1 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.6, name: "Phase 2: Overheated", effect: "Takes extra fire damage" },
          { threshold: 0.2, name: "Phase 3: Core Exposed", effect: "Takes 20% more damage" }
        ]
      },
      {
        name: "Necro-Lich",
        healthMultiplier: 0.9,
        description: "Undead lord of dark magic with a legion of spirits!",
        specialWeakness: "holy",
        palette: ['#003300', '#006600', '#009900', '#00cc00', '#00ff00', '#88ff88', '#ccffcc'],
        complexity: 6,
        symmetry: 0.6,
        tags: ["undead", "dark"],
        attackPatterns: [
          {
            name: "Life Drain",
            damage: 30,
            effect: { type: "leech", duration: 3 },
            cooldown: 7,
            execute: () => {
              lifeDrainAttack();
              return { damage: 30, effects: [{ type: "leech", duration: 3 }] };
            }
          },
          {
            name: "Summon Minions",
            damage: 20,
            effect: { type: "summon", duration: 5 },
            cooldown: 12,
            execute: () => {
              summonMinions();
              return { damage: 20, effects: [{ type: "summon", duration: 5 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.75, name: "Phase 2: Soul Harvest", effect: "Heals when dealing damage" },
          { threshold: 0.4, name: "Phase 3: Death Aura", effect: "Deals damage over time to all players" }
        ]
      },
      {
        name: "Abyssal Horror",
        healthMultiplier: 1.1,
        description: "A grotesque mass of writhing tentacles from the deep!",
        specialWeakness: "fire",
        palette: ['#330033', '#660066', '#990099', '#cc00cc', '#ff00ff', '#ff88ff', '#ffccff'],
        complexity: 7,
        symmetry: 0.3,
        tags: ["aberration", "tentacle"],
        attackPatterns: [
          {
            name: "Tentacle Whip",
            damage: 40,
            effect: { type: "poison", duration: 4 },
            cooldown: 5,
            execute: () => {
              tentacleWhipAttack();
              return { damage: 40, effects: [{ type: "poison", duration: 4 }] };
            }
          },
          {
            name: "Mind Blast",
            damage: 25,
            effect: { type: "confuse", duration: 3 },
            cooldown: 8,
            execute: () => {
              mindBlastAttack();
              return { damage: 25, effects: [{ type: "confuse", duration: 3 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.65, name: "Phase 2: Enraged", effect: "Attacks twice as fast" },
          { threshold: 0.25, name: "Phase 3: Regenerating", effect: "Heals over time" }
        ]
      },
      {
        name: "Doom Bringer",
        healthMultiplier: 1.3,
        description: "Demon lord from the underworld with apocalyptic power!",
        specialWeakness: "holy",
        palette: ['#000033', '#000066', '#000099', '#0000cc', '#0000ff', '#6666ff', '#9999ff'],
        complexity: 5,
        symmetry: 0.8,
        tags: ["demon", "dark"],
        attackPatterns: [
          {
            name: "Hellfire",
            damage: 45,
            effect: { type: "burn", duration: 4 },
            cooldown: 6,
            execute: () => {
              hellfireAttack();
              return { damage: 45, effects: [{ type: "burn", duration: 4 }] };
            }
          },
          {
            name: "Soul Crush",
            damage: 35,
            effect: { type: "fear", duration: 2 },
            cooldown: 9,
            execute: () => {
              soulCrushAttack();
              return { damage: 35, effects: [{ type: "fear", duration: 2 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.8, name: "Phase 2: Empowered", effect: "Damage increased by 30%" },
          { threshold: 0.5, name: "Phase 3: Unholy Aura", effect: "Reduces healing received by players" },
          { threshold: 0.2, name: "Phase 4: Apocalypse", effect: "Massive damage to all players" }
        ]
      },
      {
        name: "Arachnid Queen",
        healthMultiplier: 0.8,
        description: "A monstrous spider with venomous fangs and web attacks!",
        specialWeakness: "fire",
        palette: ['#333300', '#666600', '#999900', '#cccc00', '#ffff00', '#ffff88', '#ffffcc'],
        complexity: 8,
        symmetry: 0.5,
        tags: ["beast", "spider"],
        attackPatterns: [
          {
            name: "Venom Bite",
            damage: 30,
            effect: { type: "poison", duration: 5 },
            cooldown: 4,
            execute: () => {
              venomBiteAttack();
              return { damage: 30, effects: [{ type: "poison", duration: 5 }] };
            }
          },
          {
            name: "Web Trap",
            damage: 20,
            effect: { type: "root", duration: 4 },
            cooldown: 7,
            execute: () => {
              webTrapAttack();
              return { damage: 20, effects: [{ type: "root", duration: 4 }] };
            }
          }
        ],
        phases: [
          { threshold: 0.6, name: "Phase 2: Egg Sac", effect: "Spawns spiderlings periodically" },
          { threshold: 0.3, name: "Phase 3: Frenzy", effect: "Attack speed greatly increased" }
        ]
      }
    ];
    
    // Item rarities and colors
    const itemRarities = {
      common: { name: "Common", color: "#ffffff", multiplier: 1.0 },
      uncommon: { name: "Uncommon", color: "#5f5", multiplier: 1.2 },
      rare: { name: "Rare", color: "#55f", multiplier: 1.4 },
      epic: { name: "Epic", color: "#a5f", multiplier: 1.7 },
      legendary: { name: "Legendary", color: "#fa5", multiplier: 2.0 }
    };
    
    // Item types with possible stats
    const itemTypes = {
      weapon: {
        name: "Weapon",
        slots: ["mainHand", "offHand"],
        stats: ["str", "dex", "int"],
        prefixes: ["Sharp", "Heavy", "Balanced", "Deadly", "Mighty"],
        suffixes: ["of Power", "of Destruction", "of Slaying", "of the Warrior", "of the Berserker"]
      },
      armor: {
        name: "Armor",
        slots: ["head", "chest", "legs", "feet"],
        stats: ["vit", "armor"],
        prefixes: ["Sturdy", "Reinforced", "Fortified", "Impenetrable", "Tempered"],
        suffixes: ["of Defense", "of Protection", "of the Guardian", "of Resilience", "of the Wall"]
      },
      accessory: {
        name: "Accessory",
        slots: ["ring", "amulet", "trinket"],
        stats: ["str", "dex", "int", "vit", "armor"],
        prefixes: ["Shining", "Gleaming", "Ancient", "Mystical", "Arcane"],
        suffixes: ["of Vitality", "of the Sage", "of Wisdom", "of the Ages", "of the Elements"]
      }
    };
    
    // Game state variables
    let bossLevel = 1;
    const baseHealth = 1000;
    let maxHealth = baseHealth;
    let bossHealth = maxHealth;
    let currentBoss = bossTypes[0];
    let currentPhase = 1;
    let bossAttackCooldown = 0;
    let bossAttackTimer;
    let bossEffects = [];
    let specialAttackCooldown = false;
    let bossAnimationFrame;
    let bossAnimationState = 0;
    let bossAnimationDirection = 1;
    
    // Player ranking system
    const ranking = {};
    const joinedPlayers = new Set();
    const playerInventories = {};
    const playerEquipment = {};
    
    // ======================
    // DOM ELEMENTS
    // ======================
    
    // Boss mode elements
    const bossHealthText = document.getElementById('bossHealthText');
    const bossHealthFill = document.getElementById('bossHealthFill');
    const bossPhaseIndicator = document.getElementById('bossPhaseIndicator');
    const bossCanvas = document.getElementById('bossCanvas');
    const bossCtx = bossCanvas.getContext('2d');
    const bossAvatarWrapper = document.getElementById('bossAvatarWrapper');
    const bloodFlash = document.getElementById('bloodFlash');
    
    // Action buttons
    const attackBtn = document.getElementById('attackBtn');
    const specialAttackBtn = document.getElementById('specialAttackBtn');
    const ability1Btn = document.getElementById('ability1Btn');
    const ability2Btn = document.getElementById('ability2Btn');
    const inventoryBtn = document.getElementById('inventoryBtn');
    
    // Cooldown indicators
    const attackCooldownFill = document.getElementById('attackCooldownFill');
    const specialAttackCooldownFill = document.getElementById('specialAttackCooldownFill');
    const ability1CooldownFill = document.getElementById('ability1CooldownFill');
    const ability2CooldownFill = document.getElementById('ability2CooldownFill');
    
    // Common elements
    const chatLog = document.getElementById('chatLog');
    const scoreboardContent = document.getElementById('scoreboardContent');
    
    // Inventory panel elements
    const inventoryPanel = document.getElementById('inventoryPanel');
    const inventoryGrid = document.getElementById('inventoryGrid');
    const equippedItems = document.getElementById('equippedItems');
    const closeInventoryBtn = document.querySelector('.close-inventory');
    
    // ======================
    // PIXEL BOSS GENERATION
    // ======================
    
    function generatePixelBoss(bossType) {
      const size = 64;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0; // 0 = transparent
        }
      }
      
      // Generate boss body with symmetry
      const center = size / 2;
      const complexity = bossType.complexity;
      const symmetry = bossType.symmetry;
      
      for (let layer = 0; layer < complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            // Skip if already filled
            if (grid[y][x] !== 0) continue;
            
            // Determine if we should place a pixel here
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            // Base chance based on distance from center (creates circular shape)
            let chance = 1 - normalizedDist;
            
            // Add some randomness
            chance *= 0.5 + Math.random() * 0.5;
            
            // Apply layer modifier (outer layers are less dense)
            chance *= 1 - (layer / complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * bossType.palette.length);
              grid[y][x] = colorIndex + 1; // +1 because 0 is transparent
              
              // Apply symmetry
              if (Math.random() < symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add boss-specific features
      addBossFeatures(grid, bossType, center);
      
      // Render to canvas
      renderPixelGrid(grid, bossType.palette);
      
      // Start animation loop for this boss
      startBossAnimation(bossType);
    }
    
    function addBossFeatures(grid, bossType, center) {
      const size = grid.length;
      
      // Dragon features
      if (bossType.name.includes("Dragon")) {
        // Add wings
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if ((x < center - 15 || x > center + 15) && y > center - 10 && y < center + 10) {
              if (Math.random() < 0.3) {
                grid[y][x] = Math.floor(Math.random() * bossType.palette.length) + 1;
              }
            }
          }
        }
        
        // Add fiery breath area
        for (let y = center - 5; y < center + 5; y++) {
          for (let x = 0; x < center - 20; x++) {
            if (Math.random() < 0.4) {
              grid[y][x] = 5; // Bright color in palette
            }
          }
        }
        
        // Add horns
        for (let i = 0; i < 2; i++) {
          const hornX = center + (i === 0 ? -8 : 8);
          for (let y = center - 20; y < center - 10; y++) {
            if (Math.random() < 0.7) {
              grid[y][hornX] = 3; // Dark color
            }
          }
        }
      }
      // Golem features
      else if (bossType.name.includes("Golem")) {
        // Add rocky texture
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (grid[y][x] !== 0 && Math.random() < 0.2) {
              grid[y][x] = Math.max(1, grid[y][x] - 1);
            }
          }
        }
        
        // Add glowing core
        for (let y = center - 3; y <= center + 3; y++) {
          for (let x = center - 3; x <= center + 3; x++) {
            if (Math.sqrt(Math.pow(x-center,2) + Math.pow(y-center,2)) <= 3) {
              grid[y][x] = bossType.palette.length; // Brightest color
            }
          }
        }
      }
      // Spider features
      else if (bossType.name.includes("Spider")) {
        // Add legs
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const length = 20 + Math.random() * 10;
          const thickness = 2;
          
          for (let l = 0; l < length; l++) {
            const legX = Math.round(center + Math.cos(angle) * l);
            const legY = Math.round(center + Math.sin(angle) * l);
            
            for (let t = -thickness; t <= thickness; t++) {
              const tx = Math.round(legX + Math.cos(angle + Math.PI/2) * t);
              const ty = Math.round(legY + Math.sin(angle + Math.PI/2) * t);
              
              if (tx >= 0 && tx < size && ty >= 0 && ty < size) {
                grid[ty][tx] = 3; // Middle color in palette
              }
            }
          }
        }
        
        // Add eyes
        for (let i = 0; i < 8; i++) {
          const eyeAngle = (i / 8) * Math.PI * 2;
          const eyeDist = 5 + Math.random() * 3;
          const eyeX = Math.round(center + Math.cos(eyeAngle) * eyeDist);
          const eyeY = Math.round(center + Math.sin(eyeAngle) * eyeDist);
          
          if (eyeX >= 0 && eyeX < size && eyeY >= 0 && eyeY < size) {
            grid[eyeY][eyeX] = bossType.palette.length; // Brightest color
          }
        }
      }
      // Lich features
      else if (bossType.name.includes("Lich")) {
        // Add robe details
        for (let y = center + 5; y < size; y++) {
          for (let x = center - 10; x <= center + 10; x++) {
            if (Math.random() < 0.1) {
              grid[y][x] = 0; // Create holes in robe
            }
          }
        }
        
        // Add glowing eyes
        grid[center-3][center-3] = bossType.palette.length;
        grid[center-3][center+3] = bossType.palette.length;
      }
      // Horror features
      else if (bossType.name.includes("Horror")) {
        // Add random tentacles
        for (let i = 0; i < 12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const length = 15 + Math.random() * 15;
          const thickness = 1 + Math.random() * 2;
          
          for (let l = 0; l < length; l++) {
            const tentX = Math.round(center + Math.cos(angle) * l);
            const tentY = Math.round(center + Math.sin(angle) * l);
            
            for (let t = -thickness; t <= thickness; t++) {
              const tx = Math.round(tentX + Math.cos(angle + Math.PI/2) * t);
              const ty = Math.round(tentY + Math.sin(angle + Math.PI/2) * t);
              
              if (tx >= 0 && tx < size && ty >= 0 && ty < size) {
                grid[ty][tx] = 2 + Math.floor(Math.random() * 3);
              }
            }
          }
        }
      }
      // Demon features
      else if (bossType.name.includes("Demon")) {
        // Add horns
        for (let i = 0; i < 2; i++) {
          const hornX = center + (i === 0 ? -5 : 5);
          for (let y = center - 15; y < center - 5; y++) {
            grid[y][hornX] = 1; // Dark color
          }
        }
        
        // Add fiery aura
        for (let y = center - 12; y <= center + 12; y++) {
          for (let x = center - 12; x <= center + 12; x++) {
            const dist = Math.sqrt(Math.pow(x-center,2) + Math.pow(y-center,2));
            if (dist > 10 && dist <= 12 && Math.random() < 0.3) {
              grid[y][x] = bossType.palette.length; // Bright color
            }
          }
        }
      }
    }
    
    function renderPixelGrid(grid, palette) {
      const size = grid.length;
      const pixelSize = bossCanvas.width / size;
      
      bossCtx.clearRect(0, 0, bossCanvas.width, bossCanvas.height);
      
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] > 0) {
            bossCtx.fillStyle = palette[grid[y][x] - 1];
            bossCtx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
          }
        }
      }
    }
    
    // ======================
    // BOSS ANIMATIONS
    // ======================
    
    function startBossAnimation(bossType) {
      // Cancel any existing animation
      if (bossAnimationFrame) {
        cancelAnimationFrame(bossAnimationFrame);
      }
      
      // Set up animation based on boss type
      if (bossType.name.includes("Dragon")) {
        animateDragon();
      } else if (bossType.name.includes("Golem")) {
        animateGolem();
      } else if (bossType.name.includes("Spider")) {
        animateSpider();
      } else if (bossType.name.includes("Lich")) {
        animateLich();
      } else if (bossType.name.includes("Horror")) {
        animateHorror();
      } else if (bossType.name.includes("Demon")) {
        animateDemon();
      } else {
        // Default idle animation
        animateIdle();
      }
    }
    
    function animateDragon() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add animated wings
      const wingAngle = Math.sin(bossAnimationState * 0.1) * 0.2;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if ((x < center - 15 || x > center + 15) && y > center - 10 && y < center + 10) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            
            if (distFromCenter > 20 && distFromCenter < 30 && Math.random() < 0.5) {
              const angle = Math.atan2(y - center, x - center);
              const newAngle = angle + (x < center ? -wingAngle : wingAngle);
              const newX = center + Math.cos(newAngle) * distFromCenter;
              const newY = center + Math.sin(newAngle) * distFromCenter;
              
              const drawX = Math.floor(newX);
              const drawY = Math.floor(newY);
              
              if (drawX >= 0 && drawX < size && drawY >= 0 && drawY < size) {
                grid[drawY][drawX] = 4; // Wing color
              }
            }
          }
        }
      }
      
      // Add animated fire breath
      if (bossAnimationState % 30 < 15) {
        for (let y = center - 5; y < center + 5; y++) {
          for (let x = 0; x < center - 20; x++) {
            if (Math.random() < 0.4) {
              grid[y][x] = 5 + Math.floor(Math.random() * 2); // Fire colors
            }
          }
        }
      }
      
      // Add horns
      for (let i = 0; i < 2; i++) {
        const hornX = center + (i === 0 ? -8 : 8);
        for (let y = center - 20; y < center - 10; y++) {
          if (Math.random() < 0.7) {
            grid[y][hornX] = 3;
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateDragon);
    }
    
    function animateGolem() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add rocky texture with animation
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== 0 && Math.random() < 0.2) {
            const pulse = Math.sin(bossAnimationState * 0.1) * 0.5 + 0.5;
            if (Math.random() < pulse) {
              grid[y][x] = Math.max(1, grid[y][x] - 1);
            }
          }
        }
      }
      
      // Add pulsing core
      const corePulse = Math.sin(bossAnimationState * 0.2) * 0.3 + 0.7;
      for (let y = center - 3; y <= center + 3; y++) {
        for (let x = center - 3; x <= center + 3; x++) {
          if (Math.sqrt(Math.pow(x-center,2) + Math.pow(y-center,2)) <= 3 * corePulse) {
            grid[y][x] = currentBoss.palette.length;
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateGolem);
    }
    
    function animateSpider() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add animated legs
      const legAngle = Math.sin(bossAnimationState * 0.15) * 0.3;
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + legAngle * (i % 2 === 0 ? 1 : -1);
        const length = 20 + Math.random() * 10;
        const thickness = 2;
        
        for (let l = 0; l < length; l++) {
          const legX = Math.round(center + Math.cos(angle) * l);
          const legY = Math.round(center + Math.sin(angle) * l);
          
          for (let t = -thickness; t <= thickness; t++) {
            const tx = Math.round(legX + Math.cos(angle + Math.PI/2) * t);
            const ty = Math.round(legY + Math.sin(angle + Math.PI/2) * t);
            
            if (tx >= 0 && tx < size && ty >= 0 && ty < size) {
              grid[ty][tx] = 3;
            }
          }
        }
      }
      
      // Add pulsing eyes
      const eyePulse = Math.sin(bossAnimationState * 0.2) * 0.5 + 0.5;
      for (let i = 0; i < 8; i++) {
        const eyeAngle = (i / 8) * Math.PI * 2;
        const eyeDist = 5 + Math.random() * 3;
        const eyeX = Math.round(center + Math.cos(eyeAngle) * eyeDist);
        const eyeY = Math.round(center + Math.sin(eyeAngle) * eyeDist);
        
        if (eyeX >= 0 && eyeX < size && eyeY >= 0 && eyeY < size) {
          if (Math.random() < eyePulse) {
            grid[eyeY][eyeX] = currentBoss.palette.length;
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateSpider);
    }
    
    function animateLich() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add animated robe details
      const robeWave = Math.sin(bossAnimationState * 0.1);
      for (let y = center + 5; y < size; y++) {
        for (let x = center - 10; x <= center + 10; x++) {
          const waveOffset = Math.floor(robeWave * 2);
          if ((x + waveOffset) % 4 === 0 && Math.random() < 0.1) {
            grid[y][x] = 0;
          }
        }
      }
      
      // Add pulsing eyes
      const eyePulse = Math.sin(bossAnimationState * 0.2) * 0.5 + 0.5;
      if (Math.random() < eyePulse) {
        grid[center-3][center-3] = currentBoss.palette.length;
        grid[center-3][center+3] = currentBoss.palette.length;
      }
      
      // Add floating orbs
      if (bossAnimationState % 30 < 15) {
        for (let i = 0; i < 3; i++) {
          const orbAngle = bossAnimationState * 0.1 + i * Math.PI * 2 / 3;
          const orbDist = 15;
          const orbX = Math.floor(center + Math.cos(orbAngle) * orbDist);
          const orbY = Math.floor(center + Math.sin(orbAngle) * orbDist);
          
          if (orbX >= 0 && orbX < size && orbY >= 0 && orbY < size) {
            grid[orbY][orbX] = currentBoss.palette.length;
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateLich);
    }
    
    function animateHorror() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add writhing tentacles
      const tentacleWave = bossAnimationState * 0.1;
      for (let i = 0; i < 12; i++) {
        const angle = Math.random() * Math.PI * 2;
        const length = 15 + Math.random() * 15;
        const thickness = 1 + Math.random() * 2;
        
        for (let l = 0; l < length; l++) {
          const wave = Math.sin(tentacleWave + l * 0.3) * 2;
          const tentX = Math.round(center + Math.cos(angle + wave * 0.1) * l);
          const tentY = Math.round(center + Math.sin(angle + wave * 0.1) * l);
          
          for (let t = -thickness; t <= thickness; t++) {
            const tx = Math.round(tentX + Math.cos(angle + Math.PI/2) * t);
            const ty = Math.round(tentY + Math.sin(angle + Math.PI/2) * t);
            
            if (tx >= 0 && tx < size && ty >= 0 && ty < size) {
              grid[ty][tx] = 2 + Math.floor(Math.random() * 3);
            }
          }
        }
      }
      
      // Add pulsating core
      const corePulse = Math.sin(bossAnimationState * 0.15) * 0.5 + 0.5;
      for (let y = center - 5; y <= center + 5; y++) {
        for (let x = center - 5; x <= center + 5; x++) {
          if (Math.sqrt(Math.pow(x-center,2) + Math.pow(y-center,2)) <= 5 * corePulse) {
            grid[y][x] = currentBoss.palette.length;
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateHorror);
    }
    
    function animateDemon() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add animated horns
      const hornWave = Math.sin(bossAnimationState * 0.1) * 0.2;
      for (let i = 0; i < 2; i++) {
        const hornAngle = i === 0 ? -Math.PI/4 : Math.PI/4;
        const hornLength = 10;
        
        for (let l = 0; l < hornLength; l++) {
          const hornX = Math.round(center + (i === 0 ? -5 : 5) + Math.cos(hornAngle + hornWave) * l);
          const hornY = Math.round(center - 15 + Math.sin(hornAngle + hornWave) * l);
          
          if (hornX >= 0 && hornX < size && hornY >= 0 && hornY < size) {
            grid[hornY][hornX] = 1;
          }
        }
      }
      
      // Add animated fiery aura
      const auraPulse = Math.sin(bossAnimationState * 0.15) * 0.3 + 0.7;
      for (let y = center - 12; y <= center + 12; y++) {
        for (let x = center - 12; x <= center + 12; x++) {
          const dist = Math.sqrt(Math.pow(x-center,2) + Math.pow(y-center,2));
          if (dist > 10 && dist <= 12 * auraPulse && Math.random() < 0.3) {
            grid[y][x] = currentBoss.palette.length;
          }
        }
      }
      
      // Add animated wings
      if (bossAnimationState % 40 < 20) {
        for (let i = 0; i < 2; i++) {
          const wingX = center + (i === 0 ? -15 : 15);
          for (let y = center - 10; y <= center + 10; y++) {
            for (let x = i === 0 ? wingX - 5 : wingX; x <= (i === 0 ? wingX : wingX + 5); x++) {
              if (Math.random() < 0.4) {
                grid[y][x] = 4;
              }
            }
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateDemon);
    }
    
    function animateIdle() {
      const size = 64;
      const center = size / 2;
      const grid = [];
      
      // Initialize empty grid
      for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
          grid[y][x] = 0;
        }
      }
      
      // Generate base body
      for (let layer = 0; layer < currentBoss.complexity; layer++) {
        const layerSize = size - (layer * 10);
        if (layerSize <= 0) break;
        
        const startX = Math.floor((size - layerSize) / 2);
        const startY = Math.floor((size - layerSize) / 2);
        
        for (let y = startY; y < startY + layerSize; y++) {
          for (let x = startX; x < startX + layerSize; x++) {
            const distFromCenter = Math.sqrt(
              Math.pow(x - center, 2) + Math.pow(y - center, 2)
            );
            const maxDist = layerSize / 2;
            const normalizedDist = distFromCenter / maxDist;
            
            let chance = 1 - normalizedDist;
            chance *= 0.5 + Math.random() * 0.5;
            chance *= 1 - (layer / currentBoss.complexity);
            
            if (chance > 0.5) {
              const colorIndex = Math.floor(Math.random() * currentBoss.palette.length);
              grid[y][x] = colorIndex + 1;
              
              if (Math.random() < currentBoss.symmetry) {
                const symX = size - 1 - x;
                const symY = size - 1 - y;
                if (symX >= 0 && symX < size && symY >= 0 && symY < size) {
                  grid[symY][symX] = colorIndex + 1;
                }
              }
            }
          }
        }
      }
      
      // Add simple pulsing animation
      const pulse = Math.sin(bossAnimationState * 0.1) * 0.05 + 1;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] > 0 && Math.random() < 0.1) {
            const newX = Math.floor(center + (x - center) * pulse);
            const newY = Math.floor(center + (y - center) * pulse);
            
            if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
              grid[newY][newX] = grid[y][x];
              if (Math.random() < 0.3) grid[y][x] = 0;
            }
          }
        }
      }
      
      renderPixelGrid(grid, currentBoss.palette);
      
      bossAnimationState++;
      bossAnimationFrame = requestAnimationFrame(animateIdle);
    }
    
    // ======================
    // BOSS ATTACK EFFECTS
    // ======================
    
    function fireBreathAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create fire breath effect
      const fireBreath = document.createElement('div');
      fireBreath.className = 'bossProjectile';
      fireBreath.style.background = 'radial-gradient(circle, #ff6600, #ff0000)';
      fireBreath.style.width = '300px';
      fireBreath.style.height = '100px';
      fireBreath.style.left = `${bossX - 300}px`;
      fireBreath.style.top = `${bossY - 50}px`;
      fireBreath.style.borderRadius = '50px';
      fireBreath.style.boxShadow = '0 0 20px #ff6600';
      document.body.appendChild(fireBreath);
      
      // Animate fire breath
      let width = 300;
      const fireInterval = setInterval(() => {
        width -= 20;
        fireBreath.style.width = `${width}px`;
        fireBreath.style.left = `${bossX - width}px`;
        
        if (width <= 0) {
          clearInterval(fireInterval);
          fireBreath.remove();
        }
      }, 50);
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function shockwaveAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create shockwave effect
      const shockwave = document.createElement('div');
      shockwave.className = 'bossProjectile';
      shockwave.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8), rgba(200,200,255,0))';
      shockwave.style.width = '50px';
      shockwave.style.height = '50px';
      shockwave.style.left = `${bossX - 25}px`;
      shockwave.style.top = `${bossY - 25}px`;
      shockwave.style.borderRadius = '50%';
      shockwave.style.boxShadow = '0 0 10px #fff';
      document.body.appendChild(shockwave);
      
      // Animate shockwave
      let size = 50;
      let opacity = 0.8;
      const shockInterval = setInterval(() => {
        size += 20;
        opacity -= 0.05;
        shockwave.style.width = `${size}px`;
        shockwave.style.height = `${size}px`;
        shockwave.style.left = `${bossX - size/2}px`;
        shockwave.style.top = `${bossY - size/2}px`;
        shockwave.style.opacity = opacity;
        
        if (opacity <= 0) {
          clearInterval(shockInterval);
          shockwave.remove();
        }
      }, 50);
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function lifeDrainAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create life drain orbs
      for (let i = 0; i < 3; i++) {
        const orb = document.createElement('div');
        orb.className = 'bossProjectile';
        orb.style.background = 'radial-gradient(circle, #00ff00, #003300)';
        orb.style.width = '20px';
        orb.style.height = '20px';
        orb.style.left = `${bossX - 10}px`;
        orb.style.top = `${bossY - 10}px`;
        orb.style.borderRadius = '50%';
        orb.style.boxShadow = '0 0 10px #00ff00';
        document.body.appendChild(orb);
        
        // Random player position for animation target
        const targetX = bossX + (Math.random() * 400 - 200);
        const targetY = bossY + (Math.random() * 200 - 100);
        
        // Animate orb
        let progress = 0;
        const orbInterval = setInterval(() => {
          progress += 0.05;
          const x = bossX + (targetX - bossX) * progress;
          const y = bossY + (targetY - bossY) * progress;
          
          orb.style.left = `${x - 10}px`;
          orb.style.top = `${y - 10}px`;
          orb.style.opacity = 1 - progress;
          
          if (progress >= 1) {
            clearInterval(orbInterval);
            orb.remove();
            
            // Create return orb
            if (i === 2) {
              const returnOrb = document.createElement('div');
              returnOrb.className = 'bossProjectile';
              returnOrb.style.background = 'radial-gradient(circle, #ff0000, #990000)';
              returnOrb.style.width = '20px';
              returnOrb.style.height = '20px';
              returnOrb.style.left = `${targetX - 10}px`;
              returnOrb.style.top = `${targetY - 10}px`;
              returnOrb.style.borderRadius = '50%';
              returnOrb.style.boxShadow = '0 0 10px #ff0000';
              document.body.appendChild(returnOrb);
              
              let returnProgress = 0;
              const returnInterval = setInterval(() => {
                returnProgress += 0.05;
                const x = targetX + (bossX - targetX) * returnProgress;
                const y = targetY + (bossY - targetY) * returnProgress;
                
                returnOrb.style.left = `${x - 10}px`;
                returnOrb.style.top = `${y - 10}px`;
                
                if (returnProgress >= 1) {
                  clearInterval(returnInterval);
                  returnOrb.remove();
                }
              }, 50);
            }
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function summonMinions() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      for (let i = 0; i < 5; i++) {
        const minion = document.createElement('div');
        minion.className = 'bossProjectile';
        minion.style.background = '#333';
        minion.style.width = '30px';
        minion.style.height = '30px';
        minion.style.left = `${bossX - 15}px`;
        minion.style.top = `${bossY - 15}px`;
        minion.style.borderRadius = '50%';
        minion.style.boxShadow = '0 0 5px #000';
        document.body.appendChild(minion);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 100;
        const targetX = bossX + Math.cos(angle) * distance;
        const targetY = bossY + Math.sin(angle) * distance;
        
        let progress = 0;
        const minionInterval = setInterval(() => {
          progress += 0.05;
          const x = bossX + (targetX - bossX) * progress;
          const y = bossY + (targetY - bossY) * progress;
          
          minion.style.left = `${x - 15}px`;
          minion.style.top = `${y - 15}px`;
          
          if (progress >= 1) {
            clearInterval(minionInterval);
            setTimeout(() => {
              minion.remove();
            }, 5000);
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function tentacleWhipAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      for (let i = 0; i < 3; i++) {
        const tentacle = document.createElement('div');
        tentacle.className = 'bossProjectile';
        tentacle.style.background = 'linear-gradient(to right, #330033, #660066)';
        tentacle.style.width = '10px';
        tentacle.style.height = '100px';
        tentacle.style.left = `${bossX - 5}px`;
        tentacle.style.top = `${bossY - 50}px`;
        tentacle.style.transformOrigin = 'center bottom';
        document.body.appendChild(tentacle);
        
        const angle = -Math.PI/4 + (Math.PI/4 * i);
        let rotation = angle;
        let growing = true;
        let length = 100;
        
        const tentacleInterval = setInterval(() => {
          if (growing) {
            rotation += 0.1;
            length += 10;
            tentacle.style.height = `${length}px`;
            tentacle.style.transform = `rotate(${rotation}rad)`;
            
            if (rotation >= angle + Math.PI/4) {
              growing = false;
            }
          } else {
            rotation -= 0.1;
            length -= 10;
            tentacle.style.height = `${length}px`;
            tentacle.style.transform = `rotate(${rotation}rad)`;
            
            if (rotation <= angle - Math.PI/4 || length <= 0) {
              clearInterval(tentacleInterval);
              tentacle.remove();
            }
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function mindBlastAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create mind blast effect
      const blast = document.createElement('div');
      blast.className = 'bossProjectile';
      blast.style.background = 'radial-gradient(circle, #990099, #330033)';
      blast.style.width = '50px';
      blast.style.height = '50px';
      blast.style.left = `${bossX - 25}px`;
      blast.style.top = `${bossY - 25}px`;
      blast.style.borderRadius = '50%';
      blast.style.boxShadow = '0 0 20px #990099';
      document.body.appendChild(blast);
      
      // Animate blast expanding
      let size = 50;
      let opacity = 1;
      const blastInterval = setInterval(() => {
        size += 30;
        opacity -= 0.05;
        blast.style.width = `${size}px`;
        blast.style.height = `${size}px`;
        blast.style.left = `${bossX - size/2}px`;
        blast.style.top = `${bossY - size/2}px`;
        blast.style.opacity = opacity;
        
        if (opacity <= 0) {
          clearInterval(blastInterval);
          blast.remove();
        }
      }, 50);
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function hellfireAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create hellfire projectiles
      for (let i = 0; i < 5; i++) {
        const fireball = document.createElement('div');
        fireball.className = 'bossProjectile';
        fireball.style.background = 'radial-gradient(circle, #ff0000, #990000)';
        fireball.style.width = '30px';
        fireball.style.height = '30px';
        fireball.style.left = `${bossX - 15}px`;
        fireball.style.top = `${bossY - 15}px`;
        fireball.style.borderRadius = '50%';
        fireball.style.boxShadow = '0 0 10px #ff0000';
        document.body.appendChild(fireball);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 100;
        const targetX = bossX + Math.cos(angle) * distance;
        const targetY = bossY + Math.sin(angle) * distance;
        
        let progress = 0;
        const fireInterval = setInterval(() => {
          progress += 0.05;
          const x = bossX + (targetX - bossX) * progress;
          const y = bossY + (targetY - bossY) * progress;
          
          fireball.style.left = `${x - 15}px`;
          fireball.style.top = `${y - 15}px`;
          fireball.style.opacity = 1 - progress;
          
          if (progress >= 1) {
            clearInterval(fireInterval);
            fireball.remove();
            
            // Create explosion
            const explosion = document.createElement('div');
            explosion.className = 'bossProjectile';
            explosion.style.background = 'radial-gradient(circle, #ff6600, #ff0000)';
            explosion.style.width = '60px';
            explosion.style.height = '60px';
            explosion.style.left = `${targetX - 30}px`;
            explosion.style.top = `${targetY - 30}px`;
            explosion.style.borderRadius = '50%';
            explosion.style.boxShadow = '0 0 20px #ff6600';
            document.body.appendChild(explosion);
            
            let explosionSize = 60;
            let explosionOpacity = 1;
            const explosionInterval = setInterval(() => {
              explosionSize += 10;
              explosionOpacity -= 0.1;
              explosion.style.width = `${explosionSize}px`;
              explosion.style.height = `${explosionSize}px`;
              explosion.style.left = `${targetX - explosionSize/2}px`;
              explosion.style.top = `${targetY - explosionSize/2}px`;
              explosion.style.opacity = explosionOpacity;
              
              if (explosionOpacity <= 0) {
                clearInterval(explosionInterval);
                explosion.remove();
              }
            }, 50);
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function soulCrushAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create soul crush effect
      const crush = document.createElement('div');
      crush.className = 'bossProjectile';
      crush.style.background = 'radial-gradient(circle, #0000ff, #000033)';
      crush.style.width = '200px';
      crush.style.height = '200px';
      crush.style.left = `${bossX - 100}px`;
      crush.style.top = `${bossY - 100}px`;
      crush.style.borderRadius = '50%';
      crush.style.boxShadow = '0 0 30px #0000ff';
      document.body.appendChild(crush);
      
      // Animate crush
      let size = 200;
      let opacity = 1;
      const crushInterval = setInterval(() => {
        size -= 10;
        opacity -= 0.05;
        crush.style.width = `${size}px`;
        crush.style.height = `${size}px`;
        crush.style.left = `${bossX - size/2}px`;
        crush.style.top = `${bossY - size/2}px`;
        crush.style.opacity = opacity;
        
        if (opacity <= 0) {
          clearInterval(crushInterval);
          crush.remove();
        }
      }, 50);
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function venomBiteAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create venom droplets
      for (let i = 0; i < 3; i++) {
        const venom = document.createElement('div');
        venom.className = 'bossProjectile';
        venom.style.background = 'radial-gradient(circle, #00ff00, #003300)';
        venom.style.width = '15px';
        venom.style.height = '15px';
        venom.style.left = `${bossX - 7}px`;
        venom.style.top = `${bossY - 7}px`;
        venom.style.borderRadius = '50%';
        venom.style.boxShadow = '0 0 5px #00ff00';
        document.body.appendChild(venom);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 50;
        const targetX = bossX + Math.cos(angle) * distance;
        const targetY = bossY + Math.sin(angle) * distance;
        
        let progress = 0;
        const venomInterval = setInterval(() => {
          progress += 0.05;
          const x = bossX + (targetX - bossX) * progress;
          const y = bossY + (targetY - bossY) * progress + (Math.sin(progress * Math.PI) * -50);
          
          venom.style.left = `${x - 7}px`;
          venom.style.top = `${y - 7}px`;
          
          if (progress >= 1) {
            clearInterval(venomInterval);
            venom.remove();
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    function webTrapAttack() {
      const bossRect = bossAvatarWrapper.getBoundingClientRect();
      const bossX = bossRect.left + bossRect.width / 2;
      const bossY = bossRect.top + bossRect.height / 2;
      
      // Create web projectiles
      for (let i = 0; i < 3; i++) {
        const web = document.createElement('div');
        web.className = 'bossProjectile';
        web.style.background = 'radial-gradient(circle, #ffffff, #cccccc)';
        web.style.width = '30px';
        web.style.height = '30px';
        web.style.left = `${bossX - 15}px`;
        web.style.top = `${bossY - 15}px`;
        web.style.borderRadius = '50%';
        web.style.boxShadow = '0 0 5px #ffffff';
        document.body.appendChild(web);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 50;
        const targetX = bossX + Math.cos(angle) * distance;
        const targetY = bossY + Math.sin(angle) * distance;
        
        let progress = 0;
        const webInterval = setInterval(() => {
          progress += 0.05;
          const x = bossX + (targetX - bossX) * progress;
          const y = bossY + (targetY - bossY) * progress;
          
          web.style.left = `${x - 15}px`;
          web.style.top = `${y - 15}px`;
          
          if (progress >= 1) {
            clearInterval(webInterval);
            web.remove();
            
            // Create web trap
            const trap = document.createElement('div');
            trap.className = 'bossProjectile';
            trap.style.background = 'radial-gradient(circle, rgba(255,255,255,0.5), rgba(255,255,255,0))';
            trap.style.width = '80px';
            trap.style.height = '80px';
            trap.style.left = `${targetX - 40}px`;
            trap.style.top = `${targetY - 40}px`;
            trap.style.borderRadius = '50%';
            trap.style.boxShadow = '0 0 10px #ffffff';
            document.body.appendChild(trap);
            
            setTimeout(() => {
              trap.remove();
            }, 3000);
          }
        }, 50);
      }
      
      bossAvatarWrapper.classList.add('bossAttacking');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossAttacking'), 500);
    }
    
    // ======================
    // BOSS AI AND ATTACKS
    // ======================
    
    function startBossAttacks() {
      if (bossAttackTimer) {
        clearInterval(bossAttackTimer);
      }
      
      // Base cooldown between attacks
      let cooldown = 5000;
      
      // Adjust cooldown based on phase
      if (currentPhase >= 2) {
        cooldown *= 0.7; // 30% faster in phase 2
      }
      if (currentPhase >= 3) {
        cooldown *= 0.7; // Another 30% faster in phase 3 (total 51% faster)
      }
      
      bossAttackTimer = setInterval(() => {
        if (bossHealth <= 0) return;
        
        // Choose a random attack pattern
        const attackIndex = Math.floor(Math.random() * currentBoss.attackPatterns.length);
        const attack = currentBoss.attackPatterns[attackIndex];
        
        // Execute the attack
        const result = attack.execute();
        
        // Apply damage to players
        const highLevelPlayers = Object.entries(ranking)
          .filter(([_, stats]) => stats.level >= 3)
          .map(([user]) => user);
        
        if (highLevelPlayers.length > 0) {
          const damagePerPlayer = Math.floor(result.damage / highLevelPlayers.length);
          
          highLevelPlayers.forEach(user => {
            // Apply damage reduction based on equipment and stats
            const player = ranking[user];
            const damageReduction = (player.stats.vit * 0.5) + (player.equipment?.armor?.stats?.armor || 0);
            const finalDamage = Math.max(1, damagePerPlayer - damageReduction);
            
            player.damageTaken = (player.damageTaken || 0) + finalDamage;
            addChatMessage(` ${currentBoss.name} hits ${user} with ${attack.name} for ${finalDamage} damage!`);
            
            // Apply status effects
            if (result.effects && result.effects.length > 0) {
              result.effects.forEach(effect => {
                if (!player.effects) player.effects = [];
                player.effects.push({ 
                  type: effect.type, 
                  duration: effect.duration,
                  startTime: Date.now()
                });
                addChatMessage(` ${user} is affected by ${effect.type}!`);
              });
            }
          });
        }
        
        // Show phase change if health threshold crossed
        checkBossPhase();
        
      }, cooldown);
    }
    
    function checkBossPhase() {
      const healthPercent = bossHealth / maxHealth;
      const phases = currentBoss.phases;
      
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        if (healthPercent <= phase.threshold && currentPhase === i + 1) {
          currentPhase++;
          bossPhaseIndicator.textContent = phase.name;
          bossPhaseIndicator.classList.add('phaseVisible');
          addChatMessage(` ${phase.name}: ${phase.effect}`);
          
          setTimeout(() => {
            bossPhaseIndicator.classList.remove('phaseVisible');
          }, 3000);
          
          // Restart attacks with new timing
          startBossAttacks();
          break;
        }
      }
    }
    
    // ======================
    // ITEM SYSTEM
    // ======================
    
    function generateRandomItem(playerLevel) {
      // Determine item rarity
      let rarityRoll = Math.random();
      let rarity;
      
      if (rarityRoll < 0.6) {
        rarity = "common";
      } else if (rarityRoll < 0.85) {
        rarity = "uncommon";
      } else if (rarityRoll < 0.95) {
        rarity = "rare";
      } else if (rarityRoll < 0.99) {
        rarity = "epic";
      } else {
        rarity = "legendary";
      }
      
      // Determine item type
      const itemTypeKeys = Object.keys(itemTypes);
      const itemType = itemTypeKeys[Math.floor(Math.random() * itemTypeKeys.length)];
      
      // Determine slot
      const slots = itemTypes[itemType].slots;
      const slot = slots[Math.floor(Math.random() * slots.length)];
      
      // Generate name
      const prefixes = itemTypes[itemType].prefixes;
      const suffixes = itemTypes[itemType].suffixes;
      const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
      const name = `${prefix} ${itemTypes[itemType].name} ${suffix}`;
      
      // Generate stats
      const possibleStats = itemTypes[itemType].stats;
      const statCount = Math.min(2 + Math.floor(Math.random() * 2), possibleStats.length);
      
      const stats = {};
      const selectedStats = [...possibleStats].sort(() => 0.5 - Math.random()).slice(0, statCount);
      
      selectedStats.forEach(stat => {
        // Base value based on player level and rarity
        const baseValue = Math.floor((playerLevel * 2) * itemRarities[rarity].multiplier);
        // Add some random variance
        stats[stat] = baseValue + Math.floor(Math.random() * (playerLevel + 1));
      });
      
      return {
        name,
        type: itemType,
        slot,
        rarity,
        stats,
        icon: `${itemType}-${slot}` // This would be replaced with actual icon paths
      };
    }
    
    function awardLoot(username) {
      const player = ranking[username];
      if (!player || player.level < 1) return;
      
      // Chance to get loot based on player level and boss level
      const lootChance = 0.3 + (player.level * 0.02) + (bossLevel * 0.01);
      
      if (Math.random() < lootChance) {
        const item = generateRandomItem(player.level);
        
        if (!playerInventories[username]) {
          playerInventories[username] = [];
        }
        
        playerInventories[username].push(item);
        addChatMessage(` ${username} found ${item.name}! (${itemRarities[item.rarity].name})`, false, false, item.rarity);
        
        // Update inventory display if open
        if (inventoryPanel.style.display === 'block' && testUsernameInput.value === username) {
          displayInventory(username);
        }
      }
    }
    
    function equipItem(username, itemIndex) {
      const player = ranking[username];
      if (!player || !playerInventories[username] || itemIndex >= playerInventories[username].length) return;
      
      const item = playerInventories[username][itemIndex];
      
      // Initialize equipment if needed
      if (!playerEquipment[username]) {
        playerEquipment[username] = {};
      }
      
      // Check if slot is occupied
      const currentItem = playerEquipment[username][item.slot];
      
      // Swap items
      playerEquipment[username][item.slot] = item;
      playerInventories[username].splice(itemIndex, 1);
      
      if (currentItem) {
        playerInventories[username].push(currentItem);
      }
      
      // Update player stats
      updatePlayerStats(username);
      
      // Update inventory display
      displayInventory(username);
      
      addChatMessage(` ${username} equipped ${item.name}!`);
    }
    
    function unequipItem(username, slot) {
      const player = ranking[username];
      if (!player || !playerEquipment[username] || !playerEquipment[username][slot]) return;
      
      const item = playerEquipment[username][slot];
      
      if (!playerInventories[username]) {
        playerInventories[username] = [];
      }
      
      playerInventories[username].push(item);
      delete playerEquipment[username][slot];
      
      // Update player stats
      updatePlayerStats(username);
      
      // Update inventory display
      displayInventory(username);
      
      addChatMessage(` ${username} unequipped ${item.name}.`);
    }
    
    function updatePlayerStats(username) {
      const player = ranking[username];
      if (!player) return;
      
      // Reset to base stats
      player.stats = { ...playerClasses[player.class].stats };
      
      // Apply equipment bonuses
      if (playerEquipment[username]) {
        Object.values(playerEquipment[username]).forEach(item => {
          Object.entries(item.stats).forEach(([stat, value]) => {
            player.stats[stat] = (player.stats[stat] || 0) + value;
          });
        });
      }
      
      // Update scoreboard to reflect new stats
      updateScoreboard();
    }
    
    // ======================
    // INVENTORY UI
    // ======================
    
    function displayInventory(username) {
      const player = ranking[username];
      if (!player) return;
      
      // Clear current display
      equippedItems.innerHTML = '';
      inventoryGrid.innerHTML = '';
      
      // Display equipped items
      const equippedSlots = ['mainHand', 'offHand', 'head', 'chest', 'legs', 'feet', 'ring', 'amulet', 'trinket'];
      
      equippedSlots.forEach(slot => {
        const slotDiv = document.createElement('div');
        slotDiv.className = 'inventory-item';
        slotDiv.innerHTML = `
          <div>${slot.toUpperCase()}</div>
          ${playerEquipment[username] && playerEquipment[username][slot] ? 
            `<div class="item-rarity-${playerEquipment[username][slot].rarity}">
              ${playerEquipment[username][slot].name}
              <button onclick="unequipItem('${username}', '${slot}')">Unequip</button>
            </div>` : 
            '<div>Empty</div>'}
        `;
        equippedItems.appendChild(slotDiv);
      });
      
      // Display inventory items
      if (playerInventories[username]) {
        playerInventories[username].forEach((item, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'inventory-item';
          itemDiv.innerHTML = `
            <div class="item-rarity-${item.rarity}">
              ${item.name}
              <button onclick="equipItem('${username}', ${index})">Equip</button>
            </div>
          `;
          inventoryGrid.appendChild(itemDiv);
        });
      }
      
      // Show the inventory panel
      inventoryPanel.style.display = 'block';
    }
    
    // ======================
    // UTILITY FUNCTIONS
    // ======================
    
    // Add a chat message with fade-in effect
    function addChatMessage(message, isCritical = false, isMiss = false, rarity = null) {
      const messageEl = document.createElement('div');
      messageEl.textContent = message;
      
      if (isCritical) {
        messageEl.classList.add('criticalHit');
      } else if (isMiss) {
        messageEl.classList.add('miss');
      } else if (rarity) {
        messageEl.style.color = itemRarities[rarity].color;
      }
      
      chatLog.appendChild(messageEl);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    
    // Update boss health display
    function updateBossHealth() {
      if (bossHealth < 0) bossHealth = 0;
      bossHealthText.textContent = `${bossHealth} / ${maxHealth}`;
      const percent = (bossHealth / maxHealth) * 100;
      bossHealthFill.style.width = percent + "%";
      
      // Check for phase transitions
      checkBossPhase();
    }
    
    // Update scoreboard display
    function updateScoreboard() {
      const scores = Object.entries(ranking)
        .sort((a, b) => {
          if (b[1].bossesKilled === a[1].bossesKilled) {
            return b[1].damage - a[1].damage;
          }
          return b[1].bossesKilled - a[1].bossesKilled;
        });
      
      let html = scores.map(([user, stats]) => {
        let levelUpText = stats.levelUp ? `<span class="levelUp">LEVEL UP!</span>` : "";
        let classText = stats.class ? `<span class="${stats.class}">${playerClasses[stats.class].name}</span>` : "Adventurer";
        
        // Display equipped weapon if available
        let weaponText = "";
        if (playerEquipment[user] && playerEquipment[user].mainHand) {
          weaponText = `<br><small>Weapon: ${playerEquipment[user].mainHand.name}</small>`;
        }
        
        // Display status effects if any
        let effectsText = "";
        if (stats.effects && stats.effects.length > 0) {
          effectsText = "<br>";
          stats.effects.forEach(effect => {
            effectsText += `<span class="status-effect status-${effect.type}" title="${effect.type}"></span>`;
          });
        }
        
        return `
          <div>
            <strong>${user}</strong> (${classText}): ${stats.bossesKilled} boss kills, ${stats.damage} dmg, Level ${stats.level} ${levelUpText}${effectsText}<br>
            <small>XP: ${stats.xp}/${stats.level * 100}</small>${weaponText}
          </div>`;
      }).join("");
      
      scoreboardContent.innerHTML = html || "No players yet.";
      
      // Show/hide special attack button based on player levels
      const hasHighLevelPlayer = Object.values(ranking).some(player => player.level >= 5);
      specialAttackBtn.style.display = hasHighLevelPlayer ? 'block' : 'none';
    }
    
    // Show a quick blood flash overlay
    function showBloodFlash() {
      bloodFlash.classList.add('bloodVisible');
      setTimeout(() => {
        bloodFlash.classList.remove('bloodVisible');
      }, 200);
    }
    
    // Boss flicker and shake effect when hurt
    function bossFlicker() {
      bossAvatarWrapper.classList.add('hurt');
      const dx = Math.floor(Math.random() * 21) - 10;
      const dy = Math.floor(Math.random() * 11) - 5;
      bossAvatarWrapper.style.left = `calc(50% + ${dx}px)`;
      bossAvatarWrapper.style.top = `${60 + dy}px`;
      setTimeout(() => {
        bossAvatarWrapper.classList.remove('hurt');
        bossAvatarWrapper.style.left = '50%';
        bossAvatarWrapper.style.top = '60px';
      }, 300);
    }
    
    // Check if a player can level up
    function checkLevelUp(username) {
      const player = ranking[username];
      if (!player) return;
      
      let threshold = player.level * 100;
      let leveledUp = false;
      
      while (player.xp >= threshold) {
        player.xp -= threshold;
        player.level++;
        leveledUp = true;
        threshold = player.level * 100;
        
        // Award a random item on level up
        if (player.level % 3 === 0) {
          awardLoot(username);
        }
      }
      
      if (leveledUp) {
        player.levelUp = true;
        updateScoreboard();
        addChatMessage(` ${username} leveled up to level ${player.level}!`);
        
        // Remove the announcement flag after 3 seconds
        setTimeout(() => {
          player.levelUp = false;
          updateScoreboard();
        }, 3000);
      }
    }
    
    // Attack cooldown
    function startAttackCooldown(btn, cooldownFill, duration) {
      btn.disabled = true;
      let cooldown = 100;
      
      const cooldownInterval = setInterval(() => {
        cooldown--;
        cooldownFill.style.width = cooldown + '%';
        
        if (cooldown <= 0) {
          clearInterval(cooldownInterval);
          btn.disabled = false;
          cooldownFill.style.width = '100%';
        }
      }, duration / 100);
    }
    
    // Special attack cooldown
    function startSpecialAttackCooldown() {
      specialAttackCooldown = true;
      specialAttackBtn.disabled = true;
      let cooldown = 100;
      
      const cooldownInterval = setInterval(() => {
        cooldown--;
        specialAttackCooldownFill.style.width = cooldown + '%';
        
        if (cooldown <= 0) {
          clearInterval(cooldownInterval);
          specialAttackCooldown = false;
          specialAttackBtn.disabled = false;
          specialAttackCooldownFill.style.width = '100%';
        }
      }, 50);
    }
    
    // ======================
    // BOSS MODE FUNCTIONS
    // ======================
    
    // Spawn a new, harder boss with a random creature
    function spawnNewBoss(killer) {
      bossLevel++;
      currentPhase = 1;
      
      // Select a random boss from our list
      const bossIndex = Math.floor(Math.random() * bossTypes.length);
      currentBoss = bossTypes[bossIndex];
      maxHealth = Math.floor(baseHealth * currentBoss.healthMultiplier) + (bossLevel - 1) * 500;
      bossHealth = maxHealth;
      updateBossHealth();
    
      // Generate new pixel boss
      generatePixelBoss(currentBoss);
      bossAvatarWrapper.classList.add('bossEntrance');
      setTimeout(() => bossAvatarWrapper.classList.remove('bossEntrance'), 800);
    
      addChatMessage(` ${currentBoss.description}`);
      addChatMessage(` A new boss: ${currentBoss.name} (Level ${bossLevel}) has appeared!`);
    
      if (!ranking[killer]) {
        ranking[killer] = { 
          damage: 0, 
          bossesKilled: 0, 
          xp: 0, 
          level: 1, 
          levelUp: false,
          class: Object.keys(playerClasses)[Math.floor(Math.random() * Object.keys(playerClasses).length)]
        };
      }
      
      ranking[killer].bossesKilled++;
      updateScoreboard();
      
      // Start boss attacks
      startBossAttacks();
      
      // Award loot to killer
      awardLoot(killer);
    }
    
    // Special attack from high-level players
    function performSpecialAttack(username) {
      if (specialAttackCooldown) return;
      
      const highLevelPlayers = Object.entries(ranking)
        .filter(([_, stats]) => stats.level >= 5)
        .map(([user]) => user);
      
      if (highLevelPlayers.length === 0) return;
      
      // Calculate damage based on number of high-level players
      const baseDamage = 50 + (highLevelPlayers.length * 20) + Math.floor(Math.random() * 51);
      
      // Check if attack exploits boss weakness
      const isWeakness = Math.random() < 0.3; // 30% chance to exploit weakness
      let damage = isWeakness ? Math.floor(baseDamage * 1.5) : baseDamage;
      
      // Apply player stat bonuses
      highLevelPlayers.forEach(user => {
        const player = ranking[user];
        if (player.stats.str) damage += Math.floor(player.stats.str * 0.5);
        if (player.stats.int) damage += Math.floor(player.stats.int * 0.5);
      });
      
      if (isWeakness) {
        addChatMessage(` ${highLevelPlayers.join(', ')} unleash a ${currentBoss.specialWeakness.toUpperCase()} attack, exploiting ${currentBoss.name}'s weakness for ${damage} damage!`, true);
      } else {
        addChatMessage(` ${highLevelPlayers.join(', ')} combine their power for a special attack dealing ${damage} damage!`);
      }
      
      bossHealth -= damage;
      
      // Award XP to all participants
      highLevelPlayers.forEach(user => {
        ranking[user].damage += Math.floor(damage / highLevelPlayers.length);
        ranking[user].xp += Math.floor(damage / highLevelPlayers.length);
        checkLevelUp(user);
      });
      
      updateBossHealth();
      showBloodFlash();
      bossFlicker();
      updateScoreboard();
      
      // Start cooldown
      startSpecialAttackCooldown();
      
      if (bossHealth <= 0) {
        addChatMessage(` ${highLevelPlayers.join(', ')} defeated ${currentBoss.name} with a powerful special attack!`);
        bossAvatarWrapper.classList.add('bossDeath');
        
        // Award loot to all participants
        highLevelPlayers.forEach(user => {
          awardLoot(user);
        });
        
        setTimeout(() => {
          spawnNewBoss(highLevelPlayers[0]);
          bossAvatarWrapper.classList.remove('bossDeath');
        }, 800);
      }
    }
    
    // Process player attack
    function performAttack(username) {
      if (!joinedPlayers.has(username)) {
        addChatMessage(` ${username}, please join first by typing !join`);
        return;
      }
      
      const player = ranking[username];
      
      // Calculate base damage with critical chance
      const isCritical = Math.random() < (0.15 + (player.stats.dex ? player.stats.dex * 0.005 : 0));
      let damage = Math.floor(Math.random() * 41) + 10;
      
      // Apply player stat bonuses
      if (player.stats.str) damage += Math.floor(player.stats.str * 0.8);
      if (player.stats.dex) damage += Math.floor(player.stats.dex * 0.5);
      
      // Apply weapon bonus if equipped
      if (playerEquipment[username] && playerEquipment[username].mainHand) {
        const weapon = playerEquipment[username].mainHand;
        damage += weapon.stats.str ? Math.floor(weapon.stats.str * 1.2) : 0;
        damage += weapon.stats.dex ? Math.floor(weapon.stats.dex * 0.8) : 0;
      }
      
      if (isCritical) {
        damage = Math.floor(damage * 1.5);
        addChatMessage(` CRITICAL HIT! ${username} attacks ${currentBoss.name} for ${damage} damage!`, true);
      } else {
        addChatMessage(` ${username} attacks ${currentBoss.name} for ${damage} damage!`);
      }
      
      bossHealth -= damage;
      player.damage += damage;
      player.xp += damage;
      checkLevelUp(username);
      updateBossHealth();
      showBloodFlash();
      bossFlicker();
      updateScoreboard();
      
      if (bossHealth <= 0) {
        addChatMessage(` ${username} dealt the final blow to ${currentBoss.name}!`);
        bossAvatarWrapper.classList.add('bossDeath');
        
        // Award loot to killer
        awardLoot(username);
        
        setTimeout(() => {
          spawnNewBoss(username);
          bossAvatarWrapper.classList.remove('bossDeath');
        }, 800);
      }
    }
    
    // Process player ability
    function performAbility(username, abilityIndex) {
      if (!joinedPlayers.has(username)) {
        addChatMessage(` ${username}, please join first by typing !join`);
        return;
      }
      
      const player = ranking[username];
      if (!player || !player.class || !playerClasses[player.class].abilities[abilityIndex]) return;
      
      const ability = playerClasses[player.class].abilities[abilityIndex];
      const result = ability.execute(player);
      
      if (result.damage) {
        // Apply player stat bonuses to damage
        let damage = result.damage;
        if (player.stats.str) damage += Math.floor(player.stats.str * 0.5);
        if (player.stats.int) damage += Math.floor(player.stats.int * 0.8);
        
        // Apply weapon bonus if equipped
        if (playerEquipment[username] && playerEquipment[username].mainHand) {
          const weapon = playerEquipment[username].mainHand;
          damage += weapon.stats.str ? Math.floor(weapon.stats.str * 0.5) : 0;
          damage += weapon.stats.int ? Math.floor(weapon.stats.int * 1.0) : 0;
        }
        
        bossHealth -= damage;
        player.damage += damage;
        player.xp += damage;
        
        addChatMessage(` ${username} uses ${ability.name} on ${currentBoss.name} for ${damage} damage!`);
        
        if (result.effects && result.effects.length > 0) {
          result.effects.forEach(effect => {
            bossEffects.push({
              type: effect.type,
              duration: effect.duration,
              startTime: Date.now()
            });
            addChatMessage(` ${currentBoss.name} is affected by ${effect.type}!`);
          });
        }
        
        updateBossHealth();
        showBloodFlash();
        bossFlicker();
      }
      
      if (result.heal) {
        // Apply healing bonuses
        let heal = result.heal;
        if (player.stats.int) heal += Math.floor(player.stats.int * 1.0);
        
        // Find lowest health player to heal
        const players = Object.entries(ranking)
          .filter(([_, p]) => p.damageTaken > 0)
          .sort((a, b) => a[1].damageTaken - b[1].damageTaken);
        
        if (players.length > 0) {
          const target = players[0][0];
          const targetPlayer = ranking[target];
          targetPlayer.damageTaken = Math.max(0, targetPlayer.damageTaken - heal);
          addChatMessage(` ${username} uses ${ability.name} to heal ${target} for ${heal} health!`);
        } else {
          addChatMessage(` ${username} uses ${ability.name} but there's no one to heal!`);
        }
      }
      
      // Start cooldown
      if (abilityIndex === 0) {
        startAttackCooldown(ability1Btn, ability1CooldownFill, ability.cooldown * 1000);
      } else {
        startAttackCooldown(ability2Btn, ability2CooldownFill, ability.cooldown * 1000);
      }
      
      checkLevelUp(username);
      updateScoreboard();
      
      if (bossHealth <= 0) {
        addChatMessage(` ${username} defeated ${currentBoss.name} with ${ability.name}!`);
        bossAvatarWrapper.classList.add('bossDeath');
        
        // Award loot to killer
        awardLoot(username);
        
        setTimeout(() => {
          spawnNewBoss(username);
          bossAvatarWrapper.classList.remove('bossDeath');
        }, 800);
      }
    }
    
    // Process boss mode commands
    function processBossCommand(command, username = "Viewer") {
      command = command.trim();
      if (!command) return;
      
      if (command.startsWith("!join")) {
        if (!joinedPlayers.has(username)) {
          joinedPlayers.add(username);
          // Randomly choose a player class and initialize stats using the base stats from that class
          const pClass = Object.keys(playerClasses)[Math.floor(Math.random() * Object.keys(playerClasses).length)];
          ranking[username] = { 
            damage: 0, 
            bossesKilled: 0, 
            xp: 0, 
            level: 1, 
            levelUp: false,
            class: pClass,
            stats: { ...playerClasses[pClass].stats }  // Initialize player stats here
          };
          addChatMessage(` ${username} joined the fight as a ${ranking[username].class}!`);
          updateScoreboard();
        } else {
          addChatMessage(` ${username}, you have already joined.`);
        }
      } else if (command.startsWith("!attack")) {
        performAttack(username);
      } else if (command.startsWith("!special")) {
        if (!joinedPlayers.has(username)) {
          addChatMessage(` ${username}, please join first by typing !join`);
          return;
        }
        
        if (ranking[username].level < 5) {
          addChatMessage(` ${username}, you need to be level 5+ to use special attacks`);
          return;
        }
        
        performSpecialAttack(username);
      } else if (command.startsWith("!ability1")) {
        performAbility(username, 0);
      } else if (command.startsWith("!ability2")) {
        performAbility(username, 1);
      } else if (command.startsWith("!heal")) {
        if (!joinedPlayers.has(username)) {
          addChatMessage(` ${username}, please join first by typing !join`);
          return;
        }
        
        const heal = Math.floor(Math.random() * 21) + 5;
        bossHealth += heal;
        if (bossHealth > maxHealth) bossHealth = maxHealth;
        addChatMessage(` ${username} heals ${currentBoss.name} for ${heal} health!`);
        updateBossHealth();
      } else if (command.startsWith("!stats")) {
        if (!joinedPlayers.has(username)) {
          addChatMessage(` ${username}, please join first by typing !join`);
          return;
        }
        
        const stats = ranking[username];
        let classInfo = "";
        if (stats.class) {
          const pClass = playerClasses[stats.class];
          classInfo = `\nClass: ${pClass.name} - ${pClass.description}`;
          
          // Add abilities info
          classInfo += `\nAbilities:`;
          pClass.abilities.forEach((ability, index) => {
            classInfo += `\n${index+1}. ${ability.name}: ${ability.description}`;
          });
        }
        
        addChatMessage(` ${username} Stats: ${stats.bossesKilled} boss kills, ${stats.damage} dmg, Level ${stats.level} (XP: ${stats.xp}/${stats.level * 100})${classInfo}`);
      } else if (command.startsWith("!inventory")) {
        if (!joinedPlayers.has(username)) {
          addChatMessage(` ${username}, please join first by typing !join`);
          return;
        }
        
        // For testing, we'll use the test username input value
        displayInventory(testUsernameInput.value || username);
      } else if (command.startsWith("!class")) {
        if (!joinedPlayers.has(username)) {
          addChatMessage(` ${username}, please join first by typing !join`);
          return;
        }
        
        const classArg = command.split(" ")[1];
        if (classArg && playerClasses[classArg.toLowerCase()]) {
          ranking[username].class = classArg.toLowerCase();
          addChatMessage(` ${username} is now a ${ranking[username].class}!`);
          updateScoreboard();
        } else {
          const classList = Object.keys(playerClasses).join(", ");
          addChatMessage(` Available classes: ${classList}`);
        }
      } else if (command.startsWith("!help")) {
        addChatMessage(` Available commands: 
        !join - Join the battle
        !attack - Attack the boss
        !special - Special attack (Lvl 5+)
        !ability1 - Use your first class ability
        !ability2 - Use your second class ability
        !heal - Heal the boss (for fun)
        !stats - Check your stats
        !inventory - View your inventory
        !class [name] - Change your class
        !help - Show this help`);
      } else {
        // Ignore unrecognized commands
      }
    }
    
    // ======================
    // WEBSOCKET INTEGRATION
    // ======================
    const socket = new WebSocket('ws://localhost:55001');
    
    socket.addEventListener('open', () => {
      console.log('WebSocket connection established.');
      addChatMessage(' Connected to chat server!');
    });
    
    socket.addEventListener('message', (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('Received command via WebSocket:', data);
        processBossCommand(data.command, data.username);
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
      }
    });
    
    socket.addEventListener('error', (error) => {
      console.error("WebSocket error:", error);
      addChatMessage(' Connection error with chat server!');
    });
    
    socket.addEventListener('close', () => {
      console.log('WebSocket connection closed.');
      addChatMessage(' Disconnected from chat server!');
    });
    
    // ======================
    // EVENT LISTENERS
    // ======================
    attackBtn.addEventListener('click', () => {
      performAttack(testUsernameInput.value || "Player");
      startAttackCooldown(attackBtn, attackCooldownFill, 1000);
    });
    
    specialAttackBtn.addEventListener('click', () => {
      performSpecialAttack(testUsernameInput.value || "Player");
    });
    
    ability1Btn.addEventListener('click', () => {
      performAbility(testUsernameInput.value || "Player", 0);
    });
    
    ability2Btn.addEventListener('click', () => {
      performAbility(testUsernameInput.value || "Player", 1);
    });
    
    inventoryBtn.addEventListener('click', () => {
      displayInventory(testUsernameInput.value || "Player");
    });
    
    closeInventoryBtn.addEventListener('click', () => {
      inventoryPanel.style.display = 'none';
    });
    
    // ======================
    // INITIALIZATION
    // ======================
    updateBossHealth();
    updateScoreboard();
    
    // Initial boss spawn
    generatePixelBoss(currentBoss);
    bossAvatarWrapper.classList.add('bossEntrance');
    setTimeout(() => bossAvatarWrapper.classList.remove('bossEntrance'), 800);
    
    // Start boss attacks
    startBossAttacks();
    
    addChatMessage(' Welcome to PIXEL BOSS BATTLEGROUND! Type !join to fight terrifying creatures!');
    addChatMessage(` ${currentBoss.description}`);
    
    // Make helper functions available globally for HTML onclick handlers
    window.equipItem = equipItem;
    window.unequipItem = unequipItem;
  </script>
</body>
</html>
